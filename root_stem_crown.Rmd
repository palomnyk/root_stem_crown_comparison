---
title: "root_stem_crown_comparison"
output: html_notebook
author: 'Aaron Yerke'
---

This the R Notebook for collaboration with Dr. Yogini Jaiswal for her comparison of roots, stems, and crowns.

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

From Yogini:
I. Changes done in all files and annotations
* In all the files refer to the sheet: “Combined stem and roots” and “For PCA – Stem and Roots”
* All cells in pink indicate that the constituent is not present in the sample
* I believe in the previous study, we used “zeros” in rows where samples were not present.
* All values present in “Combined stem and roots” are normalised with internal standard area for GC-MS File.
* The data generated for analytes represent relative rather than absolute concentrations (semi-quantitative) based on their areas. All values generated for these compounds are therefore “unitless” but strongly correlate to absolute concentration when comparing values for the same metabolite; however, this does not apply when comparing values between different metabos.
* For LC-MS analysis there are two files, negative and positive representing 2 different modes of ionisation used for analysis to have a more comprehensive identification of compounds that can be detected/ionised in both positive and negative mode. 
* There can be compounds that may be common between both ‘positive’ and ‘negative’ mode of LC-MS analysis files. 

II. Nomenclature:
A. Crown root parts: 
  CRP: Crown root peel. 
  CNP: Crown root with ‘no’ peel
  CWP: Whole crown root
B. Lateral root parts: 
  LRP: whole lateral root
C. Stem parts: 
  SWP: Whole stem. 
  SNP: Stem with ‘no’ peel
  SP: Stem peel

III.A  Suggested comparisons by Dr. Jaiswal with Aaron's Notes
1. Whole crown root / lateral root/ stem
  Cycle through all of the metabolites and do ALL the metadata catagories
    lme(metabo ~ metad, method= "REML", random = ~1 | plant_number, data = myD)
    then anova
    
    table showing pvals for each test for each metabolite
      metabo test1 test2 test3 ...
    
2. Each part of Crown root and lateral root.
  lme with random effects of sample number
  
3. Each part of Crown root
  3 Samples each with 3 sections: CRP, CNP, CWO
    lme with random effect on sample number
    ANOVA
    
III.B  Additional tests suggested by Aaron
1. Comparison of each metabolite to the top three mds axis
  Add Pval for plant_num to show this isn't a batch effect

2. Comparison of each metadata to the top three mds axis


IV. Changes done in files for PCA analysis:

File 1: NCAT155_GCMS_7July2017 (1)
1. Refer to the sheet: “Combined stem and roots” and “For PCA – Stem and Roots”. 
2. Removed the internal standard row - “Docosanoic acid, methyl ester (IS)”, as it is an internal standard used for quality control and not a constituent. 
3. Removed putative annotations for “present” and “not present”

File 2: NCAT155-Negative mode - LC-MS
1. Refer to the sheet: “Combined stem and roots” and “For PCA – Stem and Roots”. 
2. In this file, all samples marked in green, are the same constituent but different mass adducts. 
    So I have discarded them in the sheet “For PCA – Stem and Roots”.  

File 3: NCAT155-Positive mode- LC-MS-SORTED- Roots
1. Refer to the sheet: “Combined stem and roots” and “For PCA – Stem and Roots”. 
2. In this file, all samples marked in green, are the same constituent but different mass adducts. 
    So I have discarded them in the sheet “For PCA – Stem and Roots”.  
3. For compounds with two adducts, the adduct rows with lower areas are deleted (will check with you before deletion)

Bioactive compounds:
  Kavain
  Dihydromethysticin
  Desmethoxyyangonin

Metadata categories for publication:
  experimental group
  plant part
  plant number

First load the data:
```{r}
rm(list = ls()) #clear workspace

#declare dataset
ds = 'gc'

#read in meta-data
metadata = read.table(file.path('.','gc','meta_data.csv'), 
  sep=",", 
  header=TRUE, 
  row.names = 1, 
  check.names = FALSE,
  stringsAsFactors=FALSE)

#read in raw numeric data
metabolites = read.table(file.path('.', ds,'gc_data_numeric.csv'), 
  sep=",", 
  header=TRUE, 
  row.names = 1, 
  check.names = FALSE)

dim(metabolites)
```
```{r}
#boxplot before transform
boxplot(metabolites,
  main = paste(toupper(ds), 'Data without log-transform'),
  col = as.factor(metadata['experimental group',]),
  xlab = "Experimental Groups",
  xaxt = 'n'
)
mtext(text= unique(as.factor(metadata['experimental group',])),
  side = 1,
  outer = FALSE,
  at = seq(2, 21, by = 3),
  line = 1
  )
par(new=TRUE)
stripchart(metabolites,
  method='jitter',
  jitter=.2,
  vertical=TRUE,
  add=T,
  pch=16,
  cex = 0.6,
  col = 'grey'
  )
plot.new()
legend('bottomright', 
  legend = unique(as.factor(metadata['experimental group',])), 
  col = unique(as.factor(metadata['experimental group',])), 
  pch = 19,
  cex=0.4
  )
```
This plot is hard to see.  Let's try log transform..


```{r}
metabolites = log2(metabolites + 1)
```

```{r}
boxplot(metabolites,
  main = paste(toupper(ds), 'Data with log-transform'),
  col = as.factor(metadata['experimental group',]),
  xlab = "Experimental Groups",
  xaxt = 'n'
)
mtext(text= unique(as.factor(metadata['experimental group',])),
  side = 1,
  outer = FALSE,
  at = seq(2, 21, by = 3),
  line = 1
  )
par(new=TRUE)
stripchart(metabolites,
  method='jitter',
  jitter=.2,
  vertical=TRUE,
  add=T,
  pch=16,
  cex = 0.6,
  col = 'grey'
  )
plot.new()
legend('bottomright', 
  legend = unique(as.factor(metadata['experimental group',])), 
  col = unique(as.factor(metadata['experimental group',])), 
  pch = 19,
  cex=0.4
  )
```
This tells me that we need to use the log transform.


To make publication size pdf:
```{r}
pdf(paste(ds, "OverallBoxplot.pdf", sep=""), width = 5, height = 3)
boxplot(metabolites,
  main = paste(toupper(ds), 'Data with log-transform'),
  col = as.factor(metadata['experimental group',]),
  xlab = "Experimental Groups",
  xaxt = 'n'
)
#  axis(side = 2, seq(14,26,2)) figure this out later
mtext(text= unique(as.factor(metadata['experimental group',])),
  side = 1,
  outer = FALSE,
  at = seq(2, 21, by = 3),
  line = 1
  )
par(new=TRUE)
stripchart(metabolites,
  method='jitter',
  jitter=.2,
  vertical=TRUE,
  add=T,
  pch=16,
  cex = 0.6,
  col = 'grey'
  )
plot.new()
legend('bottomright', 
  legend = unique(as.factor(metadata['experimental group',])), 
  col = unique(as.factor(metadata['experimental group',])), 
  pch = 19,
  cex=0.4
  )
dev.off()
```


Next look at PCA.
```{r}
#create PCA
group_pca = prcomp(t(na.omit(metabolites)), 
  center = TRUE,
  scale = TRUE)

#extract PCA matrix and convert to dataframe
myPCA = data.frame(group_pca$x)

summary(group_pca)

```
PCA1 and PCA2 account for 84% cummaltively.


PCA1 and PCA2
```{r}
for (i in 1:nrow(metadata)){
  plot(myPCA$PC1, myPCA$PC2,
    col=as.factor(metadata[i,]),
    main = paste(ds, 'dataset\n','Category: ', row.names(metadata)[i]),
    pch = 19,
    cex = 1.3
  )
  legend('topright', legend = unique(as.factor(metadata[i,])),
    col = unique(as.factor(unique(metadata[i,]))),
    pch = 1,
    cex=0.6
    )
}
```
PCA1 and PCA2 -> file for sending to collaborators
```{r}
pdf(paste(ds, "Pca1_2.pdf", sep=""))
for (i in 1:nrow(metadata)){
  plot(myPCA$PC1, myPCA$PC2,
    col=as.factor(metadata[i,]),
    pch = 19,
    cex = 1.3,
    main = paste(ds, 'dataset\n', 'Category: ', row.names(metadata)[i])
  )
  legend('topleft', legend = unique(as.factor(metadata[i,])),
    col = unique(as.factor(unique(metadata[i,]))),
    pch = 1,
    cex=0.6
    )
}
dev.off()
```

PCA1 and PCA3
```{r}
for (i in 1:nrow(metadata)){
  plot(myPCA$PC1, myPCA$PC3,
    xlab = 'PCA1, 66% of Variance',
    ylab = 'PCA3, 3% of Variance',
    col=as.factor(metadata[i,]),
    main = paste(ds, 'dataset\n', row.names(metadata)[i]),
    sub = paste(ds, 'dataset'),
    pch = 19,
    cex = 1.3
    )
  legend('bottomright', legend = unique(as.factor(metadata[i,])), 
    col = unique(as.factor(unique(metadata[i,]))), 
    pch = 1, 
    cex=0.6)
}
```

PCA2 and PCA3
```{r}
for (i in 1:nrow(metadata)){
  plot(myPCA$PC2, myPCA$PC3,
    col=as.factor(metadata[i,]),
    main = paste(ds, 'dataset\n', row.names(metadata)[i]),
    xlab = 'PCA2, 17% of Variance',
    ylab = 'PCA3, 6% of Variance',
    pch = 19,
    cex = 1.3
    )
  legend('bottomright', legend = unique(as.factor(metadata[i,])), 
    col = unique(as.factor(unique(metadata[i,]))),
    pch = 1,
    cex=0.6
  )
}
```


Compare each PCA or metabolite to each metadata Category using lm and anova.

Expected output: Table, 
  columns: PCAs, metadata Category, pvals
```{r}
lmMetadata = function(testingData, label){
  index = c()
  metaNames = c()
  metaPval = c()
  
  for (i1 in 1:nrow(testingData)){
    for (i2 in 1:nrow(metadata)){
      tryCatch(
       { 
        myLm = lm( unlist(testingData[i1,]) ~ as.factor(as.character(metadata[i2,])))
        index = c(index, i1)
        metaNames = c(metaNames, row.names(metadata)[i2])
        metaPval =  c(metaPval, anova(myLm)$"Pr(>F)"[1])
        },
        error=function(cond) {
          print('an error is thrown')
          message(cond)
        },
        warning=function(cond) {
          print('a warning is thrown')
          message(cond)
          # Choose a return value in case of warning
          #return(NULL)
        }
      )
    }
  }
  
  metaPvalAdj = p.adjust(metaPval, method = "BH")
  dFrame <- data.frame(metaPvalAdj,metaNames,index)
  dFrame <- dFrame [order(dFrame$metaPvalAdj),]
  
  write.table(dFrame, file=paste(ds, "MetaVs",label,"LinearMod.txt", sep = ''), row.names=FALSE, sep="\t")
  
    print(paste('dFrame$metaNames[i] ', dFrame$metaNames[i]))
  
  pdf(paste(ds,"MetaVs",label,"LinearMod.pdf", sep = ""))
  #par(mfrow=c(2,2))
  
  print(testingData[dFrame$index[1],])
  print(typeof(metadata[as.character(dFrame$metaNames[1]),]))
  print(typeof(testingData[dFrame$index[i]]))
  print(length(as.factor(as.character(metadata[as.character(dFrame$metaNames[i]),]))))
  print(length(unlist((testingData[dFrame$index[i]]))))
  print(unlist((testingData[dFrame$index[i]])))
  print(as.factor(as.character(metadata[as.character(dFrame$metaNames[1]),])))
  for( i in 1:nrow(dFrame)){
    print(i)
  	aTitle <- paste(label, dFrame$index[i], "vs",  dFrame$metaNames[i], "\nAdjusted Pvalue=", dFrame$metaPvalAdj[i])
    
    plot( as.factor(as.character(metadata[as.character(dFrame$metaNames[i]),])), unlist(testingData[dFrame$metaNames[i],]),
      main = aTitle,
      xlab = as.character(dFrame$metaNames[i]),
      ylab = paste(label, as.character(dFrame$index[i]))
      )
  }
  dev.off()
  
  print('lmMetadata complete')
}#end of lmMetadata

lmMetadata(metabolites, 'Metabolites')
```

plot( as.factor(as.character(metadata[as.character(dFrame$metadataCatagories[i]),])),
  	  unlist(testingData[as.character(dFrame$metaboliteNames[i]),]),



```{r}
myPcaT = data.frame(t(myPCA))
lmMetadata(myPcaT, 'Pca')
```


```{r}
lmMetadata(metabolites, 'Metabolites')
```


Compare each metabolite to each metadata.
  Expected output:
    Table1: 
      Columns: anova adjusted pval (sorted), metadata name, metabolite name
    Table2: 
      Names and rows of metadata and metabolites for failed attempts,
    Table3:
      Posthoc pvalues for 'plant part'
    Table4 and Table5: <- this turned out too hard for the model
      Post hoc pvalues for 'experimental group' and 'plant part'
        Table5 Columns:
          Metabolite | lateral_root - crown_root | stem - crown_root | stem - lateral_root
    Box plots for each metabolite and each metadata
```{r}
lmeMetadata = function(testingData, label){
  if(!require(nlme)){install.packages("nlme")}
  library("nlme")
  
  metaboliteNames = c()
  metadataCatagories = c()
  pvals = c()
  
  #vessel to hold the failures for future reference
  failedLme <<- data.frame(#'<<-' gives global scope
    metaboliteName = character(0), 
    metaboliteRowNum = numeric(0), 
    metadataName = character(0),
    metadataRowNum = numeric(0)
    )
  
  for (i1 in 1:nrow(testingData)){
    #print(paste('i1:',i1))
    for (i2 in 1:nrow(metadata)){
      #print(paste('i2:',i2))
      if (row.names(metadata)[i2] != 'plant number'){
        tryCatch(
          {
          metabo = unlist(testingData[i1,])
          metad = as.factor(unlist(metadata[i2,]))
          pn = unlist(metadata['plant number',])
          myD = data.frame(metabo, metad, pn)
          myLme = lme(metabo ~ metad, 
            method= "REML", 
            random = ~1 | pn, 
            na.action = 'na.omit',
            data = myD
            )
          myAnova = anova(myLme)
          myPval = myAnova$"p-value"[2]
          metaboliteNames = c(metaboliteNames, row.names(testingData)[i1])
          metadataCatagories = c(metadataCatagories, row.names(metadata)[i2])
          pvals =  c(pvals, myPval)
          },
          error=function(cond) {
            #metaboliteName, metaboliteRowNum, metadataName, metadataRowNum
            myRow = list(row.names(testingData)[i1], i1, row.names(metadata)[i2], i2)
            names(myRow) = c('metaboliteName', 'metaboliteRowNum', 'metadataName', 'metadataRowNum')
           # print(metabo)
            failedLme <<- rbind(failedLme, data.frame(myRow))
            #print('an error is thrown')
            message(cond)
            # Choose a return value in case of error
            # return(NA)
          },
          warning=function(cond) {
            print('a warning is thrown')
            myRow = list(row.names(testingData)[i1], i1, row.names(metadata)[i2], i2)
            names(myRow) = c('metaboliteName', 'metaboliteRowNum', 'metadataName', 'metadataRowNum')
            #print(names(myRow))
            failedLme = rbind(failedLme, data.frame(myRow))
            #print('failedLme warning')
            message(cond)
            # Choose a return value in case of warning
            #return(NULL)
          }
        )
      }
    }
  }
  
  pvalAdj = p.adjust(pvals, method = "BH")
  
  dFrame <- data.frame(pvals,pvalAdj,metaboliteNames,metadataCatagories)
  dFrame <- dFrame[order(dFrame$pvalAdj),]
  
  
  write.table(dFrame, file=paste(ds, "MetaVs", label, "Lme.txt", sep = ''), row.names=FALSE, sep="\t")
  
  write.table(failedLme, file=paste(ds, "FailedMetaVs", label, "Lme.txt", sep = ''), row.names=FALSE, sep="\t")
  
  pdf(paste(ds, "HistogramMetaVs", label, ".pdf", sep=""))
  hist(pvals, 
    main = paste('Histogram of lme pvalues for ', label),
    xlab = 'Uncorrected pvalues',
    breaks = 50
  )
  dev.off()
  
  pdf(paste(ds, "MetaVs", label, "Lme.pdf", sep=""))
  #par(mfrow=c(2,2))
  
  for( i in 1:nrow(dFrame)){
  	aTitle <- paste(  dFrame$metaboliteNames[i], "vs",  dFrame$metadataCatagories[i], "\nAdjusted Pvalue=", dFrame$pvalAdj[i])
  
  	plot( as.factor(as.character(metadata[as.character(dFrame$metadataCatagories[i]),])),
  	  unlist(testingData[as.character(dFrame$metaboliteNames[i]),]),
  	  main = aTitle,
  	  xlab = as.character(dFrame$metadataCatagories[i]),
  	  ylab = as.character(dFrame$metaboliteNames[i])
  	  )
  }
  dev.off()
  print('successfull run of lmeMetadata')
}#end function
```


```{r}
lmeMetadata(metabolites, 'Metabolites')
```

```{r}
lmeMetadata(t(myPCA), 'PCA')
```


Pairwise tests (code from Dr. Fodor https://github.com/afodor/metagenomicsTools/blob/master/src/scripts/aaronMetabolites/quickPairwise.txt)
```{r}
expGroups = unique(unlist(metadata['experimental group',]))
numGroups = length(expGroups)
iGroups <- vector()
jGroup <- vector()
index <- 1
pValues <- vector()
metabloliteName <- vector()
for( m in 1:nrow(metabolites) )
{	
	for ( i in 1:(numGroups-1) ) 
	{
		iData <- metabolites[m, which(metadata['experimental group', ] == expGroups[i])]
		
		for( j in i:numGroups) 
		{
			jData <- metabolites[m,which(metadata['experimental group', ] == expGroups[j])]
			if( sum(!is.na(iData)) >1 & sum(!is.na(jData)) >1   )
			{
				iGroups[index]  <- expGroups[i]
				jGroup[index] <-expGroups[j]
				pValues[index] <- t.test(iData, jData)$p.value
				metabloliteName[index] <- row.names(metabolites)[m]
				index = index + 1
				#print( paste(index, " " , metabloliteName, "\n"))
			}
		}
	}
}
myFrame <-data.frame(metabloliteName,iGroups,jGroup, pValues)
myFrame$pvalAdj = p.adjust(pValues, method="BH")
myFrame = myFrame[order(myFrame$pvalAdj),]
write.table(myFrame, file=paste(ds, 'PairwiseTtest.txt', sep = ''), row.names=FALSE, sep="\t")
sum(p.adjust(pValues, method="BH") < .1)
hist(pValues, 
  breaks = 50,
  xlab = 'Uncorrected pvalues',
  main = 'Pairwise t-tests'
  )
```

For publication purposes, I need to get just the metabolites of interest:
  Kavain
  Dihydromethysticin
  Desmethoxyyangonin
```{r}
bioActiveArr= c('Kavain', 'Dihydromethysticin', 'Dihydromethysticin.1', 'Desmethoxyyangonin')
mainBioActive = metabolites[bioActiveArr,]
lmeMetadata(mainBioActive, 'BioActive')
```

```{r}
lmMetadata(mainBioActive, 'BioActive')
```
```{r}
bioActiveTable = read.table(
  file.path('.', ds, 'output', 'gcMetaVsMetabolitesLme.txt'), 
  sep="\t", 
  header=TRUE, 
  check.names = FALSE,
  stringsAsFactors=FALSE
  )

bioActiveTable = subset(bioActiveTable, metaboliteNames %in% bioActiveArr)

```

```{r}
  #table and plots for Kavain Dihydromethysticin Desmethoxyyangonin
  selectMetab = subset(dFrame, metaNames == "Kavain" || metaNames == "Dihydromethysticin" || metaNames == 'Desmethoxyyangonin')
  write.table(newFrame, 
    file=paste(ds, label, "SelectMetab.txt", sep = ''),
    row.names=FALSE, 
    sep="\t"
  )
```


